// $legal:322:
// 
// This work is licensed under the Creative Commons
// Attribution-NonCommercial-ShareAlike 4.0 International
// License. To view a copy of this license, visit
// http://creativecommons.org/licenses/by-nc-sa/4.0/
// or send a letter to:
// 
// Creative Commons
// PO Box 1866
// Mountain View, CA 94042
// USA
// 
// ,$

//@requires "seq.fst"

module Tesseract.Ghost.Trace

   type step 'ev 'st = 
      {
         event: 'ev;
         state: 'st
      }

   type causality = 
      fun (ev_t: Type) (st_t: Type) -> 
         option (ev_t * st_t) -> Tot st_t

   type _trace 'st 'ev =
      {
         log: Seq.seq (step 'ev 'st);
         causl: causality 'ev 'st
      }

   type is_safe: #ev_t: Type -> #st_t:Type -> _trace ev_t st_t -> Type =
      fun (st_t: Type) (ev_t: Type) (tr: _trace ev_t st_t) ->
         True
         // an empty log is safe.
         (*(0 = Seq.length tr.log)
         // safety for non-empty logs
         \/ // the first state in the log must be what's generated by the causality specification when there's no preceeding step.
            ((let i0 = Seq.nth tr.log 0 in
               i0.state = tr.causl (Some (i0.event, tr.causl None)))
            // all successive states must be the product of applying the causality specification to the preceeding state in the log.
            /\ (forall idx.
                  0 < idx && idx < (Seq.length tr.log)
                  ==>
                     (let s = Seq.nth tr.log (idx - 1) in
                      let s' = Seq.nth tr.log idx in
                        tr.causl (Some (s'.event, s.state)) = s'.state)))*)

   type trace (ev_t: Type) (st_t: Type) =
      tr: _trace ev_t st_t{is_safe tr}

   val empty: #ev_t: Type -> #st_t: Type -> causality ev_t st_t -> Tot (trace ev_t st_t)
   let empty (ev_t: Type) (st_t: Type) (fn: causality ev_t st_t) = 
      {
         log = Seq.empty;
         causl = fn
      }  

   val length: #ev_t: Type -> #st_t: Type -> trace ev_t st_t -> Tot nat
   let length (ev_t: Type) (st_t: Type) tr =
      Seq.length tr.log

   val nth: #ev_t: Type -> #st_t: Type -> tr: trace ev_t st_t -> n: nat{n < length tr} -> Tot (step ev_t st_t)
   let nth (ev_t: Type) (st_t: Type) tr n =
      Seq.nth tr.log n

   val foldl: #ev_t: Type -> #st_t: Type -> #acm_t: Type -> (acm_t -> step ev_t st_t -> Tot acm_t) -> acm_t -> trace ev_t st_t -> Tot acm_t
   let foldl (ev_t: Type) (st_t: Type) fn acm tr =
      Seq.foldl fn acm tr.log

// $vim-fst:32: vim:set sts=3 sw=3 et ft=fstar:,$
